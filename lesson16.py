# Рзберём домашку:
# Дан список чисел:
# nums = [4, 7, 2, 4, 6, 2, 9, 10, 6, 12]
# Оставьте только уникальные чётные числа (без повторений),
# отсортированные по убыванию.
# У вас должен получиться такой список: [12, 10, 6, 4, 2]
nums = [4, 7, 2, 4, 6, 2, 9, 10, 6, 12]
nums_clean = []
for n in nums:
    if n not in nums_clean and n % 2 == 0:
        nums_clean.append(n)

nums_clean.sort(reverse=True)
print(nums_clean)


codcoins = [500, 500, 500, 100, 100, 100, 100]
# на прошлом уроке мы с помощь срезов меняли занчение элементов с 3 го индекса и до конца:
codcoins[3:] = [300, 300, 300, 300]
# или вот так тоже можно:
codcoins[3:] = [300] * 4
print(codcoins) # [500, 500, 500, 300, 300, 300, 300]
# то есть мы заранее должны знать сколько элементов мы хотим поменять,  в данном случае 4

# а что если нам нужно поменять значение элементов списка где 1000 элементов? Или вообше всех элементов спика?
# например, нам нужно удвоить значение всех элементов codcoins
codcoins = [500, 500, 500, 100, 100, 100, 100]
# нам пришлось бы писать вот так:
codcoins[0] = 1000
codcoins[1] = 1000
codcoins[2] = 1000
codcoins[3] = 200
codcoins[4] = 200
codcoins[5] = 200
codcoins[6] = 200
print(codcoins) # [1000, 1000, 1000, 200, 200, 200, 200]

# вы заметили, что индексы идут с 0 до 6 по возрастанию?
# а мы ведь умеем выводить числа от 0 о 6 с помощью цикла for и функции range:
for i in range(7):
    print(i)
# 0
# 1
# 2
# 3
# 4
# 5
# 6
# мы можем этот i использовать в качестве индекса
codcoins = [500, 500, 500, 100, 100, 100, 100]
for i in range(7):
    codcoins[i] = codcoins[i] * 2 # умножаем прошлое значение на 2

print(codcoins) # [1000, 1000, 1000, 200, 200, 200, 200]

# если мы посмотрим на длину списка codcoins
print(len(codcoins)) # 7
# то мы увидим, что оно равно 7
# а значим мы можем len(codcoins) вставить в range
codcoins = [500, 500, 500, 100, 100, 100, 100]
for i in range(len(codcoins)):
    codcoins[i] = codcoins[i] * 2

print(codcoins) # [1000, 1000, 1000, 200, 200, 200, 200]


# указывая начальную точку в функции range, мы можем поменять значение элементов с 3 и далее:
codcoins = [500, 500, 500, 100, 100, 100, 100]
for i in range(3, len(codcoins)):
    codcoins[i] = codcoins[i] * 2

print(codcoins) # [500, 500, 500, 200, 200, 200, 200]



# с помощью функции range мы можем не только выводить числа в столбик
# но и создавать список, используя его вместе с функцией list
lst = list(range(11))
print(lst) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# создадим список чётных чисел от 0 до 10 с помощью шага
lst = list(range(0, 11, 2))
print(lst) # [0, 2, 4, 6, 8, 10]


# как добавлять элементы из одного списка в другой список?
# попробуем через метод append
nums = [0, 2, 4, 6, 8, 10]
nums2 = [11, 12, 13, 14, 15]
nums.append(nums2)
print(nums) # [0, 2, 4, 6, 8, 10, [11, 12, 13, 14, 15]]
# список nums2 добавился в nums как отдельный элемент
# и теперь если мы проверим длину списка nums
print(len(nums)) # 7
# вывелось 7, потому что вложенный список будет считаться как один элемент


# как реально добавить элементы одного списка в другой так, чтобы не было вложенности
# для этого нам понадобится метод extend
nums = [0, 2, 4, 6, 8, 10]
nums2 = [11, 12, 13, 14, 15]
nums.extend(nums2)
print(nums) # [0, 2, 4, 6, 8, 10, 11, 12, 13, 14, 15]
# и теперь длина списка nums равно 11
print(len(nums)) # 11


# вложенные списки удобны тем, что например можно хранить список танцоров, разделённых по парам:
dancers = [['Tom', 'Kate'], ['Mike', 'Rose'], ['John', 'Mia']]
# добавим ещё одну пару так, чтобы они были вложенным списком внутри dancers:
dancers.append(['Max', 'Suzi'])
print(dancers) # [['Tom', 'Kate'], ['Mike', 'Rose'], ['John', 'Mia'], ['Max', 'Suzi']]

# выведем пару под индексом 0
print(dancers[1]) # ['Mike', 'Rose']
# чтобы вывести Rose обратимся к её индексу: индексация во вложенных списках идёт как обычно от нуля
print(dancers[1][1]) # Rose
print(dancers[3][0]) # Max

# заменим элемент Tom на Alex:
dancers[0][0] = 'Alex'
print(dancers) # [['Alex', 'Kate'], ['Mike', 'Rose'], ['John', 'Mia'], ['Max', 'Suzi']]

# удаляем элементы во вложенном списке
dancers[2].remove('Mia')
print(dancers) # [['Alex', 'Kate'], ['Mike', 'Rose'], ['John'], ['Max', 'Suzi']]
dancers[1].pop(0)
print(dancers) # [['Alex', 'Kate'], ['Rose'], ['John'], ['Max', 'Suzi']]

# добавляем элемент во вложеный список
dancers[1].append('David')
dancers[2].append('Sara')
print(dancers) # [['Alex', 'Kate'], ['Rose', 'David'], ['John', 'Sara'], ['Max', 'Suzi']]

# то есть ко вложенным спискам можно применять все методы списков, например count
print(dancers.count('Alex')) # 0
print(dancers[0].count('Alex')) # 1

# и проходиться циклом for
for d in dancers[0]:
    print(d)
# Alex
# Kate


# вложенность может быть любой
# то есть список может быть в списке в списке в списке в списке в списке
lst = [[[[[[1, 2], 3, [7, 0]]]]]]

# напишем функцию, которая принимает список и проходится по нему циклом for и 
# принтует элемент, если он не является списком
# а если элемент является списком, то этот элемент передаётся в эту же функцию рекурсивно
def open_prize(lst):
    for el in lst:
        if type(el) != list:
            print(el)
        else:
            open_prize(el)

open_prize(lst)
# 1
# 2
# 3
# 7
# 0
