# Разбор домашки:
# Это ученики 7 "а" класса:
class_7a = {'Andrew', 'Lola','Kate', 'Sara', 'Vincent', 'Jessie', 'Nate', 'Mia', 'Bob', 'Tom'}
# А это словарь с информацией о тех, кто успешно сдал экзамен среди всех семиклассников:
exam_succsess = {
    "Tom": 5,
    "Bill": 4,
    "Mia": 5,
    "Bob": 3,
    "Kate": 3,
    "Liam": 5,
    "Sara": 4}
# Вычислите, кто из 7 "а" провалил экзамен.
print(class_7a - set(exam_succsess.keys()))
# с помощью set(exam_succsess.keys()) берём только ключи из словаря exam_succsess и превращаем во множество
# с помощью знака минус из множества class_7a убираем set(exam_succsess.keys()) то есть тех, кто экзамен сдал
# результат: {'Lola', 'Andrew', 'Vincent', 'Jessie', 'Nate'} не сдали экзамен


# сегодня рассмотрим с вами ИСКЛЮЧЕНИЯ в python.
# Исключения (exceptions) в Python — это механизм обработки ошибок во время выполнения программы.
# Они позволяют программе продолжить работу после обнаружения ошибки, а не завершаться аварийно.
# В Python есть встроенные исключения, которые обрабатывают большинство типовых ошибок.
# например, когда мы пытаемся разделить число на ноль, наша программа останавливает работу и выводится ошибка ZeroDivisionError

num1 = 3
num2 = 0
# напишем программу, которая делит первое число на сторое
# но отловим случай, когда второе число равно нулю:
try: # пишем ключевое слово try (попробуй)
    print(num1 / num2) # попробуем поделить num1 на num2
except ZeroDivisionError: # но если второе число равно нулю и у нас будет ZeroDivisionError, то код не сломается, а просто выведется собщение:
    print('На ноль делить нельзя!')


# блоков except может быть несколько
# давайте обработаем случай, если вместо цифры в num1 или num2 будет строка:
num1 = 3
num2 = 'tttt'
try:
    print(num1 / num2)
except ZeroDivisionError:
    print('На ноль делить нельзя!')
except TypeError:
    print('Делить можно только число на число!')


# кроме try и except, есть блок else, который выполняется только в случае, если всё прошло без ошибок
# и блок finally, который выполняется в любом случае
try: 
    num1 = int(input('Введите первое число: '))
    num2 = int(input('Введите второе число: '))
    result = num1 / num2
except ValueError: # если пользователь ввёл строку и она не может быть превращена в число:
    print('Ошибка! Вводить можно только числа.')
except ZeroDivisionError: # если вторым числом введи ноль
    print('На ноль делить нельзя!')
else: # если не было никаких ошибок, принтуем результат деления
    print(result)
finally:
    print('Программа завершена...') # это сообщение выведется в любом случае, так как находится в блоке finally



# мы продолжим работу с исключениями после того, как познакомимся с ООП
# Объектно-ориентированное программирование (ООП) — это подход, при котором программа рассматривается как набор объектов, 
# взаимодействующих друг с другом. У каждого есть свойства и поведение.

# например, нам нужно создать сервис по типу Яндекс Такси
# для этого нужно представить основные элементы программы в виде объектов\классов
# создадим класс Taxist с основными атрибутами (свойствами):
# айди, имя, номер телефона, номер машины, марка авто, рейтинг и год получения прав
class Taxist:
    def __init__(self, id, name, phone_num, car_num, car_model, rating, staj):
        self.id = id
        self.name = name
        self.phone_num = phone_num
        self.car_num = car_num
        self.car_model = car_model
        self.rating = rating
        self.staj = staj

# создавая класс мы создаём "шаблон", по которому будут создаваться экземпляры класса
# создадим наш первый экземпляр класса (объект):
taxist_1 = Taxist(1, 'Bob', '+996778', 'X007AN', 'BMW 6', 4, 1999)
# чтобы вывести имя таксиста пишем:
print(taxist_1.name)
# точно так же выводим и другие атрибуты


# кроме атрибутов у класса могут быть методы
# сначала познакомимся с магическими методами
# Магические методы в Python, также известные как dunder-методы (от англ. double underscore),
# это специальные методы, имена которых начинаются и заканчиваются двойным подчеркиванием, например, __init__, __str__. 
# чтобы все основные данные о таксисте можно было вывести в одну строку воспользуемся магическим методом __str__
class Taxist:
    def __init__(self, id, name, phone_num, car_num, car_model, rating, staj):
        self.id = id
        self.name = name
        self.phone_num = phone_num
        self.car_num = car_num
        self.car_model = car_model
        self.rating = rating
        self.staj = staj

    def __str__(self):
        return f'Водитель: {self.name}, машина: {self.car_model}, номер машины: {self.car_num}'


taxist_1 = Taxist(1, 'Bob', '+996778', 'X007AN', 'BMW 6', 4, 1999)
# теперь, чтобы вывести инфу о таксисте, мы можем написать:
print(taxist_1) # Водитель: Bob, машина: BMW 6, номер машины: X007AN


# давайте напишем ещё один метод (не магический), который будет показывать стаж вождения
# для этого из 2025 (текущий год) минусуем год, в котором водитель получил права (staj)
class Taxist:
    def __init__(self, id, name, phone_num, car_num, car_model, rating, staj):
        self.id = id
        self.name = name
        self.phone_num = phone_num
        self.car_num = car_num
        self.car_model = car_model
        self.rating = rating
        self.staj = staj

    def __str__(self):
        return f'Водитель {self.name}, машина: {self.car_model}, {self.car_num}'

    def get_staj(self):
        from datetime import datetime # это модуль, содержащий инструменты для работы с датами и временем
        year = datetime.now().year # в переменную year сохраняем текущий год
        return year - self.staj # и из текущего года (2025) минусуем staj

taxist_1 = Taxist(1, 'Bob', '+996778', 'X007AN', 'BMW 6', 4, 1999) # права получил в 1999 году
print(taxist_1.get_staj()) # 26
# итого стаж вождения = 26