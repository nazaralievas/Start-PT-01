# Разберём домашнее задание:
# У вас есть словарь kurs_valut, содержащий курс валют по отношению к рублю:
kurs_valut = {
    "date": "2025-06-12",
    "base": "RUB",
    "rates": {
        "USD": 0.012657779,
        "EUR": 0.01111027,
        "KZT": 6.4354619696,
        "KGS": 1.106923}}
# Пользователь вводит два значения:
# 1) Сколько рублей он хочет обменять.
# 2) Валюту, в которую он хочет перевести рубли (варианты: USD, EUR, KZT, KGS)

# Ваша задача — используя словарь kurs_valut, посчитать, сколько это будет в выбранной валюте,
# и вывести результат в следующем формате:
# Сколько рублей вы хотите обменять?: 1000
# На какую валюту?: KGS
# 1000 рублей = 1106.923 KGS

# решение:
kurs_valut = {
    "date": "2025-06-12",
    "base": "RUB",
    "rates": {
        "USD": 0.012657779,
        "EUR": 0.01111027,
        "KZT": 6.4354619696,
        "KGS": 1.106923}}
rubli = int(input('Сколько рублей хотите обменять: '))
valuta = input('На какую валюту: ').upper()
result = rubli * kurs_valut['rates'][valuta]
print(f'{rubli} рублей = {result} {valuta}')


# сегодняшняя тема - МНОЖЕСТВА (англ. - SET)
# множества создаются с помощью фигурных скобок, однако в отличие от словарей состоят из элементов,
# а не из пар ключ-значение
my_set = {12, 13, 14, 5, 5, 5, 5}
print(my_set) # {13, 12, 5, 14}
# как вы видите, я создала множество my_set с несколькими пятёрками,
# но при принте вывелась только одна пятёрка. Это происходит из-за того, что
# В МНОЖЕСТВАХ НЕ МОЖЕТ БЫТЬ ДУБЛИКАТОВ
# В МНОЖЕСТВАХ ЭЛЕМЕНТЫ ЛЕЖАТ БЕЗ ПОРЯДКА (поэтому получить элемент по индексу не получится)

# добавить элемент в множество можно с помощью метода add
my_set.add(9)
print(my_set) # {5, 9, 12, 13, 14}

# удалить элемент можно с помощью метода pop, который удаляет рандомный элемент
my_set.pop()
print(my_set) # {9, 12, 13, 14}

# и с помощью метода remove, который удаляет то, что передали в скобках
my_set.remove(13)
print(my_set) # {9, 12, 14}

# если мы хотим удалить элемент, но не уверены в наличии этого элемента в множестве
# мы может воспользоваться методом discard
my_set.discard(1000000) # если такой элемент есть, то он удалится. Если нет, ничего не произойдёт

# так как в множествах не может быть дубликатов, мы может превратить список в множество
# с помощью функции set
votes = ["Trump", "Biden", "Trump", "Biden", "Trump", "Trump", "Bush"]
candidates = set(votes)
print(candidates) # {'Biden', 'Bush', 'Trump'}

# к множетсвам можно применять функции len, sorted, sum, min, max:
my_set = {12, 13, 14, 5, 5, 5, 5}
print(len(my_set)) # 4 (длина равна 4, так как три дубликата пятёрки удалились)
print(sorted(my_set)) # [5, 12, 13, 14] функция sorted возвращает отсортированный список
print(sum(my_set)) # 44
print(min(my_set)) # 5
print(max(my_set)) # 14


# ---- ОПЕРАЦИИ НАД МНОЖЕСТВАМИ ----

v_magazine = {'груши', 'яблоки', 'бананы', 'апельсины', 'арбузы', 'киви', 'ананасы'}
kupit = {'киви', 'персики', 'бананы', 'яблоки', 'мандарины'}
# ПЕРЕСЕЧЕНИЕ (intersection) позволяет получить элементы, которые есть в обоих множествах:
print(v_magazine & kupit) # {'киви', 'яблоки', 'бананы'}

# РАЗНОСТЬ (difference) позволяет получить элементы множества kupit без элементов множества v_magazine
ostalos_kupit = kupit - v_magazine
print(ostalos_kupit) # {'персики', 'мандарины'}

# ОБЪЕДИНЕНИЕ (union) объединяет два множества
print(v_magazine | kupit)
# {'яблоки', 'киви', 'арбузы', 'персики', 'мандарины', 'груши', 'апельсины', 'бананы', 'ананасы'}

# СИММЕТРИЧЕСКАЯ РАЗНОСТЬ объединяет два множества, удаляя элементы, которые есть в обоих множествах
print(v_magazine ^ kupit)
# {'арбузы', 'персики', 'апельсины', 'мандарины', 'груши', 'ананасы'}


# задача, которую решали в классе:
# Перед вами сет всех футболистов:
all_players = {'Jose', 'Noah', 'Harry', 'Luca', 'Jake', 'Henry', 'George', 'Theo', 'Oliver', 'Matthew', 'Aaron', 'Logan', 'Leo', 'Austin', 'Sebastian', 'Yusuf', 'Arthur', 'Oscar', 'Max'}
# Для того, чтобы вступить в сборную команду по футболу, кандидатуру должны
# одобрить и тренер, и директор клуба.

# Директор выбрал:
directors_choice = {'Jose', 'Sebastian', 'Harry', 'Luca', 'Jake', 'Henry', 'George', 'Theo', 'Oliver', 'Matthew', 'Aaron'}

# Тренер выбрал:
coachs_choise = {'George', 'Theo', 'Oliver', 'Matthew', 'Aaron', 'Logan', 'Leo', 'Austin', 'Sebastian', 'Yusuf', 'Jake'}

# 1 - Выведите список игроков, прошедших в сборную (в алфавитном порядке)
print(sorted(directors_choice & coachs_choise))
# ['Aaron', 'George', 'Jake', 'Matthew', 'Oliver', 'Sebastian', 'Theo']

# 2 - Выведите список игроков, которые были выбраны или тренером, или директором клуба (в алфавитном порядке)
print(sorted(directors_choice ^ coachs_choise))
# ['Austin', 'Harry', 'Henry', 'Jose', 'Leo', 'Logan', 'Luca', 'Yusuf']

# 3 - Выведите список игроков, которых не выбрал никто (в алфавитном порядке).
print(sorted(all_players - (directors_choice | coachs_choise)))
# ['Arthur', 'Max', 'Noah', 'Oscar']


# следующая тема - КОРТЕЖ (англ. tuple)
# кортежи создаются с помощью круглых скобок
my_tup = (1, 3, 56, 2, 2, 2)
print(my_tup) # (1, 3, 56, 2, 2, 2)
# как вы видите, дубликаты не удаляются и порядок не меняется
# поэтому мы можем получить элемент по индексу:
print(my_tup[0])
print(my_tup[-2])

# однако поменять значение элемента не получится, так как кортежи относятся к неизменемым типам данных
# но если внутри кортежа есть список, то его менять можно:
my_tup = (1, 2, [3, 4])
my_tup[2].append(100)
print(my_tup) # (1, 2, [3, 4, 100])

# у кортежей тоже есть метод count, который считает количество вхождений элемента
my_tup = (1, 3, 56, 2, 2, 2)
print(my_tup.count(2)) # 3
# и метод index, который возвращает индекс нужного элемента
print(my_tup.index(56)) # 2

# кортежи могут быть вложенными:
data = (('name', 'Mike'), ('age', 17), ('married', True))
print(data[0]) # ('name', 'Mike')
print(data[0][1]) # Mike

# такой кортеж можно превратить в словарь с помощью функции dict
print(dict(data)) # {'name': 'Mike', 'age': 17, 'married': True}


# так как кортежи (если внутри нет списка) являются неизменяемыми,
# их можно использовать в качестве ключей в словарях
# и с помощью котрежей можно создать СОСТАВНЫЕ КЛЮЧИ:
users = {
    ('Will', 'Smith'): '021234567554',
    ('Jeff', 'Bezos'): '006675647389',}

print(users[('Jeff', 'Bezos')]) # 006675647389

# с помощью метода keys, мы можем пройтись циклом for по ключам словаря users
for k in users.keys():
    print(k)
# ('Will', 'Smith')
# ('Jeff', 'Bezos')

# давайте выведем только имена пользователей:
for k in users.keys():
    print(k[0])
# Will
# Jeff

# теперь выведем именя и номер телефона, передавая ключ users[k]
for k in users.keys():
    print(k[0], users[k])
# Will 021234567554
# Jeff 006675647389

# такой же вывод можно получить с помощью метода items, который дает доступ к ключам и значениям одновременно
# соответственно, нам понадобится две переменные
for k, v in users.items():
    print(k, v)
# ('Will', 'Smith') 021234567554
# ('Jeff', 'Bezos') 006675647389

for k, v in users.items():
    print(k[0], v)
# Will 021234567554
# Jeff 006675647389